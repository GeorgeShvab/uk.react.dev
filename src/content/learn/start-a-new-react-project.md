---
title: Старт нового проєкту на React
---

<Intro>

Якщо ви вирішили розробити новий застосунок або новий вебсайт цілком за допомогою React, ми радимо обрати один зі фреймворків, заряджених React, популярних у нашій спільноті.

</Intro>


React можна користуватися без фреймворку, проте ми з'ясували, що більшість застосунків і сайтів, зрештою, розробляють рішення для поширених проблем, наприклад, розбиття коду, маршрутизації, отримання даних і генерування HTML. Ці проблеми — спільні для всіх бібліотек UI, а не лише для React.

Обравши фреймворк, можна швидко почати роботу з React і уникнути, по суті, розробки власного фреймворку пізніше.

<DeepDive>

#### Чи можна скористатися React без фреймворку? {/*can-i-use-react-without-a-framework*/}

React цілком можна використовувати без фреймворку, — так само, як можна [використовувати React у частині сторінки.](/learn/add-react-to-an-existing-project#using-react-for-a-part-of-your-existing-page) **Проте якщо ви розробляєте новий застосунок або сайт повністю на React, ми радимо скористатися фреймворком.**

І ось чому.

Навіть якщо вам спершу не потрібні маршрутизація чи отримання даних, то існує ймовірність того, що ви захочете додати для цих можливостей кілька бібліотек. Поки ваш згорток JavaScript розростатиметься з кожною новою можливістю, ви можете захотіти розібратися, як розбити код на порції для кожного окремого маршруту. Поки ваші потреби з отримання даних ускладнюватимуться, ймовірно, ви зустрінете серверно-клієнтські мережеві водоспади, що зроблять ваш застосунок дуже повільним. Коли серед ваших користувачів з'явиться більше осіб з поганим з'єднанням і бюджетними пристроями, вам може знадобитися генерувати HTML на основі компонентів, щоб виводити вміст рано — або на сервері, або під час збирання сайту. Змінювати налаштування для запуску частини коду на сервері чи під час збирання може бути дуже хитрим завданням.

**Ці проблеми не є особливими для React. Це саме те, через що в Svelte є SvelteKit, у Vue є Nuxt і так далі.** Щоб розв'язати ці проблеми самотужки, доведеться інтегрувати свій бандлер зі своїм маршрутизатором і зі своєю бібліотекою отримання даних. Неважко змусити працювати вкупі якийсь базовий варіант, проте є чимало тонкощів у створенні застосунку, який швидко завантажується навіть тоді, коли виріс з часом. Захочеться надсилати до браузера якнайменшу кількість коду застосунку, але робити це за один захід клієнт-сервер, щоб паралельно завантажувалися всі дані, необхідні на сторінці. Ймовірно, захочеться, щоб сторінка була інтерактивною навіть до запуску коду JavaScript, щоб підтримувалось поступове покращення. Може захотітися генерувати теку цілком статичних файлів HTML для рекламних сторінок, які можуть викладатися будь-де й працювати навіть із вимкненим JavaScript. Розробка таких можливостей вимагає суттєвих зусиль.

**Фреймворки React на цій сторінці розв'язують проблеми штибу цієї самі по собі, не потребуючи додаткових зусиль з вашого боку.** Вони дають змогу почати з малого, аби потім масштабувати застосунок відповідно до потреб. Кожний фреймворк на React має свою спільноту, тож шукати відповіді на питання та оновлювати інструменти розробки буде легше. Також фреймворки задають структуру коду, допомагаючи вам та іншим зберігати той самий контекст і користуватися тими ж навичками в різних проєктах. І навпаки, у випадку саморобних налаштувань легше застрягнути в версіях залежностей, що більше не підтримуються, і по суті доведеться створювати власний фреймворк — але без власної спільноти та інструкцій з оновлення (і якщо він буде схожим на те, що колись писали ми, то цей ваш фреймворк буде написаний абияк).

Якщо ваш застосунок містить незвичні обмеження, які погано накладаються на фреймворки, перелічені нижче, або ви хочете розв'язувати ці проблеми самотужки, то можете розгорнути власне налаштування з React. Візьміть `react` і `react-dom` з npm, налаштуйте власний процес збирання з використанням бандлеру штибу [Vite](https://vitejs.dev/) або [Parcel](https://parceljs.org/) і додайте інші інструменти, що знадобляться, наприклад, для маршрутизації, статичної генерації, серверного рендерингу чи чогось іще.

</DeepDive>

## Фреймворки React, готові до промислового використання {/*production-grade-react-frameworks*/}

Ці фреймворки підтримують усі можливості, що знадобляться для розгортання та масштабування застосунку в реальній роботі, та прямують до підтримки нашого [бачення архітектури повного стеку](#which-features-make-up-the-react-teams-full-stack-architecture-vision). Усі фреймворки, які ми радимо, є відкритим програмним забезпеченням, що має активні спільноти для підтримки, і їх можна розгортати на власних серверах чи сторнніх хостингах. Якщо ви автор фреймворку, зацікавлений у потраплянні до цього списку, [будь ласка, повідомте нас](https://github.com/reactjs/react.dev/issues/new?assignees=&labels=type%3A+framework&projects=&template=3-framework.yml&title=%5BFramework%5D%3A+).

### Next.js {/*nextjs-pages-router*/}

**[Page Router від Next.js](https://nextjs.org/) — це фреймворк React повного стеку.** Він багатоцільовий та дає змогу розробляти застосунки React будь-якого розміру — від здебільшого статичних блогів до складних динамічних програм. Щоб створити новий проєкт Next.js, запустіть у терміналі:

<TerminalBlock>
npx create-next-app@latest
</TerminalBlock>

Якщо Next.js — це для вас дещо нове, то погляньте на [курс вивчення Next.js.](https://nextjs.org/learn)

Next.js підтримується [Vercel](https://vercel.com/). [Розгорнути застосунок Next.js](https://nextjs.org/docs/app/building-your-application/deploying) можна на будь-якому хостингу, що підтримує Node.js чи є безсерверним, а також на власному сервері. Також Next.js підтримує [статичне експортування](https://nextjs.org/docs/pages/building-your-application/deploying/static-exports), якому не потрібен сервер.

### Remix {/*remix*/}

**[Remix](https://remix.run/) — це фреймворк React повного стеку зі вкладеною маршрутизацією.** Він дає змогу розбивати застосунок на вкладені одна в одну частини, які можуть паралельно завантажувати дані та оновлювати їх, реагуючи на дії користувача. Щоб створити новий проєкт Remix, запустіть:

<TerminalBlock>
npx create-remix
</TerminalBlock>

Якщо Remix — це для вас щось нове, погляньте його [підручник з блогом](https://remix.run/docs/en/main/tutorials/blog) (коротке) і [підручник із застосунком](https://remix.run/docs/en/main/tutorials/jokes) (довге).

Remix підтримується [Shopify](https://www.shopify.com/). При створенні проєкту Remix необхідно [обрати свою ціль розгортання](https://remix.run/docs/en/main/guides/deployment). Застосунок Remix можна розгорнути на будь-якому хостингу, що підтримує Node.js або є безсерверним, за допомогою готового чи власного [адаптера](https://remix.run/docs/en/main/other-api/adapter).

### Gatsby {/*gatsby*/}

**[Gatsby](https://www.gatsbyjs.com/) — це фреймворк React для швидких вебсайтів, заснованих на CMS.** Його багата екосистема втулок і його шар даних GraphQL спрощують інтегрування вмісту, API і сторонніх служб в один вебсайт. Щоб створити новий проєкт Gatsby, запустіть:

<TerminalBlock>
npx create-gatsby
</TerminalBlock>

Якщо Gatsby — це для вас щось нове, погляньте [підручник Gatsby.](https://www.gatsbyjs.com/docs/tutorial/)

Gatsby підтримується [Netlify](https://www.netlify.com/). [Цілком статичний сайт Gatsby можна розгорнути](https://www.gatsbyjs.com/docs/how-to/previews-deploys-hosting) на будь-якому статичному хостингу. При бажанні скористатися суто серверними можливостями фреймворку слід перевірити, що хостинг підтримує ці можливості для Gatsby.

### Expo (для нативних застосунків) {/*expo*/}

**[Expo](https://expo.dev/) — це фреймворк React, що дає змогу створювати універсальні застосунки для Android, iOS і Вебу з по-справжньому нативним UI.** Він пропонує набір інструментів для [React Native](https://reactnative.dev/), завдяки якому цими нативними частинами легше користуватися. Щоб створити новий проєкт Expo, запустіть:

<TerminalBlock>
npx create-expo-app
</TerminalBlock>

Якщо Expo - це для вас щось нове, погляньте [підручник Expo](https://docs.expo.dev/tutorial/introduction/).

Expo підтримується [Expo (компанією)](https://expo.dev/about). Розробляти застосунки за допомогою Expo можна безкоштовно, і їх можна подавати до каталогів застосунків Google і Apple без жодних обмежень. На додачу Expo пропонує необов'язкові платні хмарні послуги.

## Найсвіжіші застоунки React {/*bleeding-edge-react-frameworks*/}

Під час досліджень заради подальшого покращення React ми усвідомили, що тісніша інтеграція React зі фреймворками (а саме — з маршрутизацією, згортанням і серверними технологіями) — це наша найбільша нагода допомогти користувачам React створювати кращі застосунки. Команда Next.js погодилася співпрацювати з нами щодо досліджень, розробки, інтегрування та тестування незалежних від фреймворків можливостей React штибу [серверних компонентів React.](/blog/2023/03/22/react-labs-what-we-have-been-working-on-march-2023#react-server-components)

Ці можливості наближаються до готовності до використання в промисловості з кожним днем, і ми обговорюємо їх інтегрування з іншими розробниками бандлерів і фреймворків. Сподіваємося, що за рік чи два усі фреймворки, перелічені на цій сторінці, матимуть підтримку цих можливостей. (Якщо ви автор фреймворку, зацікавлений у співпраці щодо експериментів з цими можливостями, будь ласка, повідомте нас!)

### Next.js (App Router) {/*nextjs-app-router*/}

**[App Router від Next.js](https://nextjs.org/docs) — це переробка API Next.js, що прагне втілити бачення повностекової архітектури команди React.** Вона дає змогу отримувати дані в асинхронних компонентах, що запускаються на сервері чи навіть під час збирання.

Next.js підтримується [Vercel](https://vercel.com/). [Застосунок Next.js можна розгорнути](https://nextjs.org/docs/app/building-your-application/deploying) на будь-якому хостингу, що підтримує Node.js або є безсерверним, а також на власному сервері. Також Next.js підтримує [статичне експортування](https://nextjs.org/docs/app/building-your-application/deploying/static-exports), якому не потрібен сервер.

<DeepDive>

#### З яких можливостей складається бачення архітектури повного стеку від команди React? {/*which-features-make-up-the-react-teams-full-stack-architecture-vision*/}

Бандлер App Router від Next.js повністю реалізує офіційну [специфікацію Серверних компонентів React](https://github.com/reactjs/rfcs/blob/main/text/0188-server-components.md). Це дає змогу поєднувати компоненти, що запускаються під час збирання, ті, що працюють суто на сервері, та інтерактивні компоненти — в єдине дерево React.

Наприклад, можна написати суто серверний компонент React у вигляді функції `async`, що зчитує дані з бази даних або з файлу. Потім можна передати дані далі, до інтерактивних компонентів:

```js
// Цей компонент запускається *лише* на сервері (або під час збирання).
async function Talks({ confId }) {
  // 1. Ви на сервері, тож можете спілкуватися зі своїм шаром даних. Робити запити HTTP до API — необов'язково.
  const talks = await db.Talks.findAll({ confId });

  // 2. Додавайте будь-яку кількість логіки рендерингу. Це не збільшить результівний згорток JavaScript.
  const videos = talks.map(talk => talk.video);

  // 3. Передайте дані далі, до компонентів, що запустяться в браузері.
  return <SearchableVideoList videos={videos} />;
}
```

App Router від Next.js також інтегрує [отримання даних із Suspense](/blog/2022/03/29/react-v18#suspense-in-data-frameworks). Це дає змогу задати стан завантаження (наприклад, заповнювач-скелет) для різних частин користувацького інтерфейсу безпосередньо в дереві React:

```js
<Suspense fallback={<TalksLoading />}>
  <Talks confId={conf.id} />
</Suspense>
```

Серверні компоненти та Suspense — це радше можливості React, аніж можливості Next.js. Проте залучення їх на рівні фреймворку вимагає нетривіальних зусиль з реалізації. Наразі App Router Next.js — це найповніша реалізація. Команда React працює вкупі з розробниками бандлерів, щоб ці можливості легше було реалізувати в наступному поколінні фреймворків.

</DeepDive>
